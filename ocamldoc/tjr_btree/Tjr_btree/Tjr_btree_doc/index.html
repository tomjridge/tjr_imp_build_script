<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tjr_btree_doc (tjr_btree.Tjr_btree.Tjr_btree_doc)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">tjr_btree</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Tjr_btree.Tjr_btree_doc</span></h1></header><p>Main documentation entry point.</p><p>This file contains general documentation and an overview of the
code. Follow the links to individual modules for more information.</p><h2>Introduction</h2><p>This library implements a B-tree in OCaml. The source is actually
exported from Isabelle, and then OCaml code wraps the
Isabelle-generated code. This is the documentation for the OCaml
wrapper. The documentation for the core B-tree routines can be found
in the <code class="code">isa_btree</code> repository.</p><p>This document gives an overview of the (sub)packages and a guide to
the structure of the code. Detailed
comments are included in the individual modules.</p><h2>Ancestor projects</h2><p>See the <code class="code">README.org</code> in the project root directory for a list of
dependencies.</p><h2>Directory structure</h2><p>The code is organized into subdirectories (subpackages), and the
subdirectories are in a linear order (which corresponds to the
dependencies between modules). For example, the first subdirectory
(ignoring <code class="code">aa_from_isa</code> since it is not used) is <code class="code">ac_test</code> which is
discussed in the section &quot;Test&quot; below.</p><h2>Naming conventions</h2><p>To understand the interfaces, we need to introduce the following:</p><ul><li>Keys, represented by type variable <code class="code">'k</code></li><li>Values, type var <code class="code">'v</code></li><li>Page/block references, <code class="code">'r</code></li><li>Global state, <code class="code">'t</code></li></ul><h2>Monads!</h2><p>The entire development is parameterized by some notion of
monad. Before reading the rest of the documentation, please look at
the module <a href="../../../tjr_monad/Tjr_monad/index.html">Tjr_monad</a> from ancestor project <code class="code">tjr_monad</code>. Essentially
we use a type <code class="code">('a,'t) m</code>, where <code class="code">'t</code> is some phantom type var that is
used to identify a particular monad instance. There is an associated
type <code class="code">'t monad_ops</code> which provides the expected return and bind. In
order to get parametricity over the monad, we are forced to pass
<code class="code">monad_ops</code> as parameters to many functions.</p><h2>Exported code from Isabelle</h2><p>Exported code is in the <code class="code">isa_btree</code> opam/ocamlfind package. The
<code class="code">from_isa</code> package here is not used. FIXME</p><h2>Test</h2><p>Some simple testing utility functions.</p><h2>Base types</h2><p>This package contains basic B-tree related types:</p><ul><li><a href="../Base_types/index.html">Base_types</a> includes most of the other modules in this package</li><li><a href="../Base_types_pervasives/index.html">Base_types_pervasives</a> which includes utility functions assumed by
the other modules</li><li><a href="../Block/index.html">Block</a> for blocks on disk</li><li>Constants which give size constraints on B-tree nodes FIXME now
in isa_btree</li><li><a href="../Frame/index.html">Frame</a> which imports the Isabelle frame type</li><li><a href="../Ls_state/index.html">Ls_state</a> for the leaf stream state</li><li><a href="../Ord/index.html">Ord</a> for orderings (typically over keys)</li><li><a href="../Params/index.html">Params</a> for various projection functions from a &quot;parameters&quot; object</li><li><a href="../R2f/index.html">R2f</a> and <a href="../R2t/index.html">R2t</a> for internal types used in testing (convert a
block ref to a frame/tree)</li><li><a href="../Rstk/index.html">Rstk</a> for the type of framestacks</li><li><a href="../String_/index.html">String_</a> for various string utility functions</li><li><a href="../Tree/index.html">Tree</a> for the tree type imported from Isabelle</li></ul><p>The <a href="../Tree/index.html">Tree</a> module describes a B-tree as an algebraic datatype. The
on-disk B-tree uses references between blocks i.e. a graph-like
structure with pointers rather than a datatype. Indeed, the tree
datatype is used only for testing purposes.</p><h2>Api</h2><p>This package gives the main interface types, including interfaces for
disk, store and map.</p><ul><li><a href="../Disk_ops/index.html">Disk_ops</a> for the low-level block interface</li><li><a href="../Leaf_stream_ops/index.html">Leaf_stream_ops</a> and <a href="../Leaf_stream_util/index.html">Leaf_stream_util</a> for leaf streams</li><li><a href="../Map_ops/index.html">Map_ops</a> for map operations, find etc.</li><li><a href="../Page_ref_int/index.html">Page_ref_int</a> utility module to fix page ref as an integer</li><li><a href="../Pre_map_ops/index.html">Pre_map_ops</a> like <a href="../Map_ops/index.html">Map_ops</a> but with explicit state passing</li><li><a href="../Store_ops/index.html">Store_ops</a> for a layer just above <a href="../Disk_ops/index.html">Disk_ops</a></li></ul><p>In addition, the leaf stream interface allows to iterate over the
leaves in a B-tree e.g. to find all the bindings in the map. This
module also documents the type variable naming conventions (see
<a href="../Map_ops/index.html">Map_ops</a>).</p><p><b>Important note on code style:</b> Interfaces are essentially groups of
polymorphic functions, collected together and named using a record
type. For example, map operations are something of the form
<code class="code">('k,'v,'t) map_ops</code>. To get a handle on the components of such a
thing we provide functions such as <a href="../Map_ops/index.html#val-dest_map_ops">Map_ops.dest_map_ops</a> which takes
a set of map operations and a &quot;continuation&quot; function and calls the
function with the components of the record. Example code should make
this clearer:</p><pre>dest_imperative_map_ops map_ops @@ fun ~find ~insert ~delete -&gt;
  (* write values *)
  for x=1 to max do
    insert (k x) (v x);
  done;</pre><h2>Store to map</h2><p>This package, particularly the <a href="../Store_to_map/index.html">Store_to_map</a> module, wraps the
Isabelle routines to implement a map interface on top of a
store. The key function is <a href="../Store_to_map/index.html#val-store_ops_to_map_ops">Store_to_map.store_ops_to_map_ops</a>
which takes a <code class="code">store_ops</code> and returns a <code class="code">map_ops</code>.</p><p>Also included here are <a href="../Big_step/index.html">Big_step</a> (to iterate the small step
operations provided by Isabelle) and <a href="../Iter_leaf_stream/index.html">Iter_leaf_stream</a> (to wrap
small-step leaf stream operations).</p><h2>Disks</h2><p><a href="../Disk_on_fd/index.html">Disk_on_fd</a> is a persistent block device on top of a &quot;normal&quot; file.</p><p><a href="../Disk_to_store/index.html">Disk_to_store</a> includes a function that naively transforms a disk
to a store.</p><h2>Stores</h2><p><a href="../Mem_store/index.html">Mem_store</a> is an in-memory store.</p><p><a href="../Recycling_store/index.html">Recycling_store</a> is a store that optimizes page alloc and free to
avoid too many unnecessary writes. Currently commented out. FIXME?</p><h2>Binprot marshalling</h2><p><a href="../Binprot_marshalling/index.html">Binprot_marshalling</a> provides on-disk marshalling courtesy of
<code class="code">binprot</code>. You can, of course, provide your own marshalling code,
which may be useful if your backend doesn't support binprot (js_of_ocaml?)</p><h2>Cache</h2><p>A generic LRU Cache on top of a map. This is rather more
sophisticated than usual because we have to do various things when
cache entries (eg uncommitted disk operations) are flushed.</p><h2>Examples</h2><p>Various examples.</p><p><a href="../Bin_prot_util/index.html">Bin_prot_util</a> is a very small module which defines eg
<code class="code">bp_size_int</code>.</p><p><a href="../Bytestore/index.html">Bytestore</a> provides a mechanism to store arbitrary length byte
buffers on top of a store. Currently commented out. FIXME?</p><p><a href="../Digest_/index.html">Digest_</a> provides a digest/hash of a string, for situations where a
string is used as a key, but the exact contents of the string is not needed.</p><p><a href="../Examples_common/index.html">Examples_common</a></p><p><a href="../Map_int_blk/index.html">Map_int_blk</a> provides a map from blk index to blk</p><p><a href="../Map_int_blkx/index.html">Map_int_blkx</a> provides a map from blk index to (partial) blk (i.e.,
only the first part of the blk is used).</p><p><a href="../Map_int_int/index.html">Map_int_int</a> provides a map from int to int, using <code class="code">binprot</code>
marshalling.</p><p><a href="../Map_on_fd/index.html">Map_on_fd</a> is a generic map backed by a file descriptor.</p><p><a href="../Mem_map/index.html">Mem_map</a> is a generic map on top of the <a href="../Mem_store/index.html">Mem_store</a>.</p><p><a href="../Small_string/index.html">Small_string</a> provides a string with a max size of 256 bytes
(using arbitrary length strings as keys requires another approach).</p><p><a href="../Ss_ss_map_on_fd/index.html">Ss_ss_map_on_fd</a> implements an on-disk map from small string to
small string.</p><h2>Testing</h2><p>Various modules to support testing. Some of this looks a bit
suspicious. FIXME</p><h2>Doc</h2><p>Contains this overview documentation in module <a href="index.html">Tjr_btree_doc</a>.</p><div class="spec val" id="val-dummy"><a href="#val-dummy" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dummy : int</code></div><div class="doc"></div></div></body></html>