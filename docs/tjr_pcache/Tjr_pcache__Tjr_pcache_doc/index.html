<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tjr_pcache__Tjr_pcache_doc (tjr_pcache.Tjr_pcache__Tjr_pcache_doc)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">tjr_pcache</a> &#x00BB; Tjr_pcache__Tjr_pcache_doc</nav><h1>Module <code>Tjr_pcache__Tjr_pcache_doc</code></h1><p>Main documentation entry point for <code>tjr_pcache</code></p><nav class="toc"><ul><li><a href="#introduction">Introduction</a></li></ul></nav></header><section><header><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><p>This library implements a persistent cache (pcache), i.e., an on-disk cache. This should be used with <code>tjr_btree</code> to reduce the writes going to the B-tree.</p><p>The main modules are included below.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Persistent_list">Tjr_pcache.Persistent_list</a></code></span></summary><aside></aside><aside><p>A persistent-on-disk list</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Pl_types">Tjr_pcache.Pl_types</a></code></span></summary><aside></aside><dl><dt class="spec type" id="type-pl_state_ops"><a href="#type-pl_state_ops" class="anchor"></a><code><span class="keyword">type </span>('a, 'ptr, 'i) pl_state_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-pl_state_ops.set_data" class="anchored"><td class="def field"><a href="#type-pl_state_ops.set_data" class="anchor"></a><code>set_data : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr><tr id="type-pl_state_ops.set_next" class="anchored"><td class="def field"><a href="#type-pl_state_ops.set_next" class="anchor"></a><code>set_next : <span class="type-var">'ptr</span> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr><tr id="type-pl_state_ops.new_node" class="anchored"><td class="def field"><a href="#type-pl_state_ops.new_node" class="anchor"></a><code>new_node : <span class="type-var">'ptr</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr></table><code>}</code></dt><dd><p>The persistent list state. Each node consists of data and a possible next pointer (initially None, but may be set subsequently). For <code>new_node</code>, the ptr is the ptr of the new block, and the second argument is the data.</p><p>NOTE the type <code>'a</code> is the type of the data stored in each node.</p><p>Type variables:</p><ul><li><code>'a</code> the type of data stored in pl nodes</li><li><code>'ptr</code> the type of pointers to nodes; each node has an optional next pointer</li><li><code>'i</code> the internal state of the persistent list FIXME rename?</li></ul></dd></dl><dl><dt class="spec type" id="type-pl_ops"><a href="#type-pl_ops" class="anchor"></a><code><span class="keyword">type </span>('a, 'ptr, 't) pl_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-pl_ops.replace_last" class="anchored"><td class="def field"><a href="#type-pl_ops.replace_last" class="anchor"></a><code>replace_last : <span class="type-var">'a</span> <span>&#45;&gt;</span> (unit, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-pl_ops.new_node" class="anchored"><td class="def field"><a href="#type-pl_ops.new_node" class="anchor"></a><code>new_node : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr></table><code>}</code></dt><dd><p>The operations provided by the persistent list.</p><ul><li><code>replace_last</code> replaces the contents of the last element of the list.</li><li><code>new_node</code> allocates a new node at the end of the list and makes it the &quot;current&quot; node.</li></ul></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-make_persistent_list"><a href="#val-make_persistent_list" class="anchor"></a><code><span class="keyword">val </span>make_persistent_list : monad_ops:<span class="type-var">'t</span> <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-monad_ops">Tjr_monad.Types.monad_ops</a> <span>&#45;&gt;</span> pl_state_ops:(<span class="type-var">'a</span>, <span class="type-var">'ptr</span>, <span class="type-var">'i</span>) <a href="index.html#type-pl_state_ops">pl_state_ops</a> <span>&#45;&gt;</span> write_node:(<span class="type-var">'i</span> <span>&#45;&gt;</span> (unit, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>) <span>&#45;&gt;</span> with_pl:(<span class="type-var">'i</span>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-with_state">Tjr_monad.Types.with_state</a> <span>&#45;&gt;</span> alloc:(unit <span>&#45;&gt;</span> (<span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>) <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="../Tjr_pcache/Pl_types/index.html#type-pl_ops">Tjr_pcache.Pl_types.pl_ops</a></code></dt><dt class="spec value" id="val-pl_to_nodes"><a href="#val-pl_to_nodes" class="anchor"></a><code><span class="keyword">val </span>pl_to_nodes : read_node:(<span class="type-var">'ptr</span> <span>&#45;&gt;</span> <span class="type-var">'blks</span> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'ptr</span> option) <span>&#45;&gt;</span> ptr:<span class="type-var">'ptr</span> <span>&#45;&gt;</span> blks:<span class="type-var">'blks</span> <span>&#45;&gt;</span> (<span class="type-var">'ptr</span><span class="keyword"> * </span>(<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'ptr</span> option)) list</code></dt><dd><p>Unmarshal a persistent list to a list of nodes.</p></dd></dl><dl><dt class="spec value" id="val-pl_to_list"><a href="#val-pl_to_list" class="anchor"></a><code><span class="keyword">val </span>pl_to_list : read_node:(<span class="type-var">'ptr</span> <span>&#45;&gt;</span> <span class="type-var">'blks</span> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'ptr</span> option) <span>&#45;&gt;</span> ptr:<span class="type-var">'ptr</span> <span>&#45;&gt;</span> blks:<span class="type-var">'blks</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Convenience to unmarshal to a list of node contents</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Persistent_chunked_list">Tjr_pcache.Persistent_chunked_list</a></code></span></summary><aside></aside><aside><p>Implement a &quot;chunked&quot; list (multiple items per node) using <code>Persistent_list</code>. Automatically create a new node when the current fills up.</p><p>NOTE not concurrent safe; access must be serialized.</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Pcl_types">Tjr_pcache.Pcl_types</a></code></span></summary><aside></aside><dl><dt class="spec type" id="type-pcl_state_ops"><a href="#type-pcl_state_ops" class="anchor"></a><code><span class="keyword">type </span>('pl_data, 'e, 'i) pcl_state_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-pcl_state_ops.nil" class="anchored"><td class="def field"><a href="#type-pcl_state_ops.nil" class="anchor"></a><code>nil : unit <span>&#45;&gt;</span> <span class="type-var">'i</span>;</code></td></tr><tr id="type-pcl_state_ops.snoc" class="anchored"><td class="def field"><a href="#type-pcl_state_ops.snoc" class="anchor"></a><code>snoc : <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> <span>&#45;&gt;</span> [ `Error_too_large<span class="keyword"> | </span>`Ok of <span class="type-var">'i</span> ];</code></td></tr><tr id="type-pcl_state_ops.pl_data" class="anchored"><td class="def field"><a href="#type-pcl_state_ops.pl_data" class="anchor"></a><code>pl_data : <span class="type-var">'i</span> <span>&#45;&gt;</span> <span class="type-var">'pl_data</span>;</code></td></tr></table><code>}</code></dt><dd><p>Pure interface for manipulating the <code>pcl_state</code>. Type vars:</p><ul><li><code>'i</code> the internal pcl state type (kept abstract)</li><li><code>'e</code> the non-marshalled element type</li><li><code>'pl_data</code> the type of data stored in a persistent list node (there is also a pointer in the pl node)</li></ul><p>Functions:</p><ul><li><code>nil</code> the empty state corresponding to a new node created when the old node is full; use pl_data to get the underlying pl_node</li><li><code>snoc</code> to add an element</li><li><code>pl_data</code> to project from the pcl state to the actual data to be written</li></ul><p>NOTE that the &quot;next&quot; pointer manipulation has been confined to the persistent list interface.</p></dd></dl><dl><dt class="spec type" id="type-inserted_type"><a href="#type-inserted_type" class="anchor"></a><code><span class="keyword">type </span>'ptr inserted_type</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-inserted_type.Inserted_in_current_node" class="anchored"><td class="def constructor"><a href="#type-inserted_type.Inserted_in_current_node" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Inserted_in_current_node</span></code></td></tr><tr id="type-inserted_type.Inserted_in_new_node" class="anchored"><td class="def constructor"><a href="#type-inserted_type.Inserted_in_new_node" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Inserted_in_new_node</span><span class="keyword"> of </span><span class="type-var">'ptr</span></code></td></tr></table></dt><dd><p>A type that records whether an element was inserted in the current node, or whether a new node was allocated to hold the element.</p></dd></dl><dl><dt class="spec type" id="type-pcl_ops"><a href="#type-pcl_ops" class="anchor"></a><code><span class="keyword">type </span>('e, 'ptr, 't) pcl_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-pcl_ops.insert" class="anchored"><td class="def field"><a href="#type-pcl_ops.insert" class="anchor"></a><code>insert : <span class="type-var">'e</span> <span>&#45;&gt;</span> (<span class="type-var">'ptr</span> <a href="index.html#type-inserted_type">inserted_type</a>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr></table><code>}</code></dt><dd><p>The interface exposed by the persistent chunked list, a single <code>insert</code> function. NOTE how 'pl_data and 'i have disappeared.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-make_pcl_ops"><a href="#val-make_pcl_ops" class="anchor"></a><code><span class="keyword">val </span>make_pcl_ops : monad_ops:<span class="type-var">'t</span> <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-monad_ops">Tjr_monad.Types.monad_ops</a> <span>&#45;&gt;</span> pl_ops:(<span class="type-var">'pl_data</span>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="../Tjr_pcache/Pl_types/index.html#type-pl_ops">Tjr_pcache.Pl_types.pl_ops</a> <span>&#45;&gt;</span> pcl_state_ops:(<span class="type-var">'pl_data</span>, <span class="type-var">'e</span>, <span class="type-var">'i</span>) <a href="index.html#type-pcl_state_ops">pcl_state_ops</a> <span>&#45;&gt;</span> with_pcl:(<span class="type-var">'i</span>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/With_state/index.html#type-with_state">Tjr_monad.With_state.with_state</a> <span>&#45;&gt;</span> (<span class="type-var">'e</span>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="index.html#type-pcl_ops">pcl_ops</a></code></dt><dd><p>Function to construct a persistent chunked list. Parameters:</p><ul><li><code>pl_ops</code> The underlying persistent list operations.</li><li><code>pcl_state_ops, with_pcl</code> For the internal state of the pcl.</li></ul></dd></dl><dl><dt class="spec value" id="val-pcl_to_nodes"><a href="#val-pcl_to_nodes" class="anchor"></a><code><span class="keyword">val </span>pcl_to_nodes : read_node:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span><span class="keyword"> * </span><span class="type-var">'a</span> option) <span>&#45;&gt;</span> ptr:<span class="type-var">'a</span> <span>&#45;&gt;</span> blks:<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span>(<span class="type-var">'c</span><span class="keyword"> * </span><span class="type-var">'a</span> option)) list</code></dt><dd><p>This is just <code>pl_to_nodes</code></p></dd></dl><dl><dt class="spec value" id="val-pcl_to_es_node_list"><a href="#val-pcl_to_es_node_list" class="anchor"></a><code><span class="keyword">val </span>pcl_to_es_node_list : read_node:(<span class="type-var">'ptr</span> <span>&#45;&gt;</span> <span class="type-var">'blks</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> list<span class="keyword"> * </span><span class="type-var">'ptr</span> option) <span>&#45;&gt;</span> ptr:<span class="type-var">'ptr</span> <span>&#45;&gt;</span> blks:<span class="type-var">'blks</span> <span>&#45;&gt;</span> (<span class="type-var">'ptr</span><span class="keyword"> * </span>(<span class="type-var">'e</span> list<span class="keyword"> * </span><span class="type-var">'ptr</span> option)) list</code></dt><dd><p>As <code>pcl_to_nodes</code></p></dd></dl><dl><dt class="spec value" id="val-pcl_to_elt_list_list"><a href="#val-pcl_to_elt_list_list" class="anchor"></a><code><span class="keyword">val </span>pcl_to_elt_list_list : read_node:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> list<span class="keyword"> * </span><span class="type-var">'a</span> option) <span>&#45;&gt;</span> ptr:<span class="type-var">'a</span> <span>&#45;&gt;</span> blks:<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'e</span> list list</code></dt><dd><p>Drop pointers from <code>pcl_to_es_node_list</code></p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Detachable_chunked_list">Tjr_pcache.Detachable_chunked_list</a></code></span></summary><aside></aside><aside><p>A &quot;detachable list&quot;, with an operation <code>detach</code> to drop everything but the current node.</p><p>NOTE this code is not concurrent safe. Access must be serialized.</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Dcl_types">Tjr_pcache.Dcl_types</a></code></span></summary><aside></aside><aside><p>The DCL types</p></aside><dl><dt class="spec type" id="type-abs_ops"><a href="#type-abs_ops" class="anchor"></a><code><span class="keyword">type </span>('op, 'abs) abs_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-abs_ops.empty" class="anchored"><td class="def field"><a href="#type-abs_ops.empty" class="anchor"></a><code>empty : <span class="type-var">'abs</span>;</code></td></tr><tr id="type-abs_ops.add" class="anchored"><td class="def field"><a href="#type-abs_ops.add" class="anchor"></a><code>add : <span class="type-var">'op</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span>;</code></td></tr><tr id="type-abs_ops.merge" class="anchored"><td class="def field"><a href="#type-abs_ops.merge" class="anchor"></a><code>merge : <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span> <span>&#45;&gt;</span> <span class="type-var">'abs</span>;</code></td></tr></table><code>}</code></dt><dd><p>Operations on the &quot;abstract&quot; state. The pcl state is something like a list of map operations. The 'abs type is something like the &quot;map&quot; view of these operations (needed because the list is redundant, or at the very least inefficient for map operations). Type vars:</p><ul><li><code>'op</code> is eg insert(k,v), delete(k)</li><li>'abs is the &quot;abstraction&quot;</li></ul><p>Operations:</p><ul><li>empty, the empty map</li><li>add, to add an operation to the abstract state</li><li>merge, to merge two maps (second takes precedence); used when a new node is created, and the old node is merged into the accumulated past nodes.</li></ul></dd></dl><dl><dt class="spec value" id="val-abs_singleton"><a href="#val-abs_singleton" class="anchor"></a><code><span class="keyword">val </span>abs_singleton : abs_ops:(<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-abs_ops">abs_ops</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt></dl><dl><dt class="spec type" id="type-dcl_state"><a href="#type-dcl_state" class="anchor"></a><code><span class="keyword">type </span>('ptr, 'abs) dcl_state</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-dcl_state.start_block" class="anchored"><td class="def field"><a href="#type-dcl_state.start_block" class="anchor"></a><code>start_block : <span class="type-var">'ptr</span>;</code></td></tr><tr id="type-dcl_state.current_block" class="anchored"><td class="def field"><a href="#type-dcl_state.current_block" class="anchor"></a><code>current_block : <span class="type-var">'ptr</span>;</code></td></tr><tr id="type-dcl_state.block_list_length" class="anchored"><td class="def field"><a href="#type-dcl_state.block_list_length" class="anchor"></a><code>block_list_length : int;</code></td></tr><tr id="type-dcl_state.abs_past" class="anchored"><td class="def field"><a href="#type-dcl_state.abs_past" class="anchor"></a><code>abs_past : <span class="type-var">'abs</span>;</code></td></tr><tr id="type-dcl_state.abs_current" class="anchored"><td class="def field"><a href="#type-dcl_state.abs_current" class="anchor"></a><code>abs_current : <span class="type-var">'abs</span>;</code></td></tr></table><code>}</code></dt><dd><p>The state of the DCL. Fields are:</p><ul><li><code>start_block</code> is the root of the log</li><li><code>current_block</code> is the current block being written to</li><li><code>abs_past</code> is the abstract view of ops from root to just before <code>current_block</code></li><li><code>abs_current</code> is the abstract view of ops for the current block</li></ul><p>NOTE unlike Pl and Pcl, we have a concrete type for the state, since we don't expect to have any extra info stored at this point. (FIXME what about dcl_dummy_implementation where we need to store all ptrs?) But perhaps we can avoid some of these extra type params if we keep dcl state abstract as <code>'dcl_state</code>. But this seems unlikely.</p><p>NOTE <code>block_list_length</code>: this is the number of blocks from the underlying chunked list, used to store the ops (not the abstract representation!)</p><p>NOTE upto this point, the pl and the pcl have not explicitly tracked the start of the list. FIXME perhaps they should? This has advantages in that the abstraction is self-contained.</p></dd></dl><dl><dt class="spec type" id="type-dcl_ops"><a href="#type-dcl_ops" class="anchor"></a><code><span class="keyword">type </span>('op, 'abs, 'ptr, 't) dcl_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-dcl_ops.add" class="anchored"><td class="def field"><a href="#type-dcl_ops.add" class="anchor"></a><code>add : <span class="type-var">'op</span> <span>&#45;&gt;</span> (unit, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-dcl_ops.peek" class="anchored"><td class="def field"><a href="#type-dcl_ops.peek" class="anchor"></a><code>peek : unit <span>&#45;&gt;</span> ((<span class="type-var">'ptr</span>, <span class="type-var">'abs</span>) <a href="index.html#type-dcl_state">dcl_state</a>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-dcl_ops.detach" class="anchored"><td class="def field"><a href="#type-dcl_ops.detach" class="anchor"></a><code>detach : unit <span>&#45;&gt;</span> ((<span class="type-var">'ptr</span>, <span class="type-var">'abs</span>) <a href="index.html#type-dcl_state">dcl_state</a>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-dcl_ops.block_list_length" class="anchored"><td class="def field"><a href="#type-dcl_ops.block_list_length" class="anchor"></a><code>block_list_length : unit <span>&#45;&gt;</span> (int, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr></table><code>}</code></dt><dd><p>The DCL ops:</p><ul><li><code>add</code> to add an op</li><li><code>peek</code> to reveal the dcl_state (FIXME why?)</li><li><code>detach</code> to issue a detach operation (eg prior to rolling the past entries into a B-tree)</li><li><code>block_list_length</code> to provide information to help determine when to roll up</li></ul><p>The <code>detach</code> operation means that we should start a new cache from the current block.</p><p>The return result is the ptr and map corresponding to the contents of everything up to the current block, and the ptr and map for the current block. The intention is that the detached part is then rolled into the B-tree. If we only have 1 block, then nothing is rolled up. This occurs when <code>old_ptr</code> is the same as <code>new_ptr</code> FIXME use a new type</p><p>NOTE detach returns the dcl_state since this includes at least all the fields we need.</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-make_dcl_ops"><a href="#val-make_dcl_ops" class="anchor"></a><code><span class="keyword">val </span>make_dcl_ops : monad_ops:<span class="type-var">'t</span> <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-monad_ops">Tjr_monad.Types.monad_ops</a> <span>&#45;&gt;</span> pcl_ops:(<span class="type-var">'op</span>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="../Tjr_pcache/Pcl_types/index.html#type-pcl_ops">Tjr_pcache.Pcl_types.pcl_ops</a> <span>&#45;&gt;</span> with_dcl:((<span class="type-var">'ptr</span>, <span class="type-var">'abs</span>) <a href="index.html#type-dcl_state">dcl_state</a>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/With_state/index.html#type-with_state">Tjr_monad.With_state.with_state</a> <span>&#45;&gt;</span> abs_ops:(<span class="type-var">'op</span>, <span class="type-var">'abs</span>) <a href="index.html#type-abs_ops">abs_ops</a> <span>&#45;&gt;</span> (<span class="type-var">'op</span>, <span class="type-var">'abs</span>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="index.html#type-dcl_ops">dcl_ops</a></code></dt><dd><p>Construct the dcl operations. Parameters:</p><ul><li><code>monad_ops</code>, the monadic operations</li><li><code>pcl_ops</code>, the persistent chunked list ops</li><li><code>with_dcl</code>, access the dcl state</li><li><code>abs_ops</code>, operations on the abstract data (see <code>Detachable_map</code> for an example where the abstract data is a map)</li></ul></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Detachable_map">Tjr_pcache.Detachable_map</a></code></span></summary><aside></aside><aside><p>As <code>Detachable_chunked_list</code>, but with the operations insert and delete; and the abstract view a map.</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Tjr_pcache/index.html#module-Dmap_types">Tjr_pcache.Dmap_types</a></code></span></summary><aside></aside><aside><p>A dmap is effectively just a DCL with a refined 'op type and 'abs type. However, we also include functionality to convert to a standard map interface (not one based on ops).</p></aside><dl><dt class="spec type" id="type-op_map"><a href="#type-op_map" class="anchor"></a><code><span class="keyword">type </span>('k, 'v) op_map</code><code><span class="keyword"> = </span>(<span class="type-var">'k</span>, (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Tjr_pcache/Ins_del_op_type/index.html#type-op">Tjr_pcache.Ins_del_op_type.op</a>) <a href="../../tjr_polymap/Tjr_polymap/index.html#type-t">Tjr_polymap.t</a></code></dt><dd><p>Abbreviation; FIXME move to Ins_del_op_type</p></dd></dl><dl><dt class="spec type" id="type-dmap_state"><a href="#type-dmap_state" class="anchor"></a><code><span class="keyword">type </span>('ptr, 'k, 'v) dmap_state</code><code><span class="keyword"> = </span>(<span class="type-var">'ptr</span>, (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-op_map">op_map</a>) <a href="../Tjr_pcache/Dcl_types/index.html#type-dcl_state">Tjr_pcache.Dcl_types.dcl_state</a></code></dt><dd><p>NOTE dmap_state is just an abbreviation for dcl_state</p></dd></dl><dl><dt class="spec value" id="val-internal_"><a href="#val-internal_" class="anchor"></a><code><span class="keyword">val </span>internal_ : ptr:<span class="type-var">'ptr</span> <span>&#45;&gt;</span> abs:(<span class="type-var">'k</span>, (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Tjr_pcache/Ins_del_op_type/index.html#type-op">Tjr_pcache.Ins_del_op_type.op</a>) <a href="../../tjr_polymap/Tjr_polymap/index.html#type-t">Tjr_polymap.t</a> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-dmap_dcl_ops"><a href="#type-dmap_dcl_ops" class="anchor"></a><code><span class="keyword">type </span>('ptr, 'k, 'v, 't) dmap_dcl_ops</code><code><span class="keyword"> = </span>((<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Tjr_pcache/Ins_del_op_type/index.html#type-op">Tjr_pcache.Ins_del_op_type.op</a>, (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-op_map">op_map</a>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="../Tjr_pcache/Dcl_types/index.html#type-dcl_ops">Tjr_pcache.Dcl_types.dcl_ops</a></code></dt><dd><p>NOTE dmap_dcl_ops is just an abbreviation for dcl_ops with:</p><ul><li>'op the type of kv op</li><li>'abs the type of kv op_map</li></ul></dd></dl><dl><dt class="spec type" id="type-detach_info"><a href="#type-detach_info" class="anchor"></a><code><span class="keyword">type </span>('k, 'v, 'ptr) detach_info</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-detach_info.past_map" class="anchored"><td class="def field"><a href="#type-detach_info.past_map" class="anchor"></a><code>past_map : (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-op_map">op_map</a>;</code></td></tr><tr id="type-detach_info.current_map" class="anchored"><td class="def field"><a href="#type-detach_info.current_map" class="anchor"></a><code>current_map : (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-op_map">op_map</a>;</code></td></tr><tr id="type-detach_info.current_ptr" class="anchored"><td class="def field"><a href="#type-detach_info.current_ptr" class="anchor"></a><code>current_ptr : <span class="type-var">'ptr</span>;</code></td></tr></table><code>}</code></dt><dd><p>The result of &quot;detaching&quot; the map. We get the abstract map for all but the current node, and information about the current node.</p></dd></dl><dl><dt class="spec type" id="type-dmap_ops"><a href="#type-dmap_ops" class="anchor"></a><code><span class="keyword">type </span>('k, 'v, 'ptr, 't) dmap_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-dmap_ops.find" class="anchored"><td class="def field"><a href="#type-dmap_ops.find" class="anchor"></a><code>find : <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'v</span> option, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-dmap_ops.insert" class="anchored"><td class="def field"><a href="#type-dmap_ops.insert" class="anchor"></a><code>insert : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> (unit, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-dmap_ops.delete" class="anchored"><td class="def field"><a href="#type-dmap_ops.delete" class="anchor"></a><code>delete : <span class="type-var">'k</span> <span>&#45;&gt;</span> (unit, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-dmap_ops.detach" class="anchored"><td class="def field"><a href="#type-dmap_ops.detach" class="anchor"></a><code>detach : unit <span>&#45;&gt;</span> ((<span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'ptr</span>) <a href="index.html#type-detach_info">detach_info</a>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr><tr id="type-dmap_ops.block_list_length" class="anchored"><td class="def field"><a href="#type-dmap_ops.block_list_length" class="anchor"></a><code>block_list_length : unit <span>&#45;&gt;</span> (int, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-m">Tjr_monad.Types.m</a>;</code></td></tr></table><code>}</code></dt><dd><p>For the detach operation, we get the map upto the current node, and the map for the current node</p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-make_dmap_dcl_ops"><a href="#val-make_dmap_dcl_ops" class="anchor"></a><code><span class="keyword">val </span>make_dmap_dcl_ops : monad_ops:<span class="type-var">'t</span> <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-monad_ops">Tjr_monad.Types.monad_ops</a> <span>&#45;&gt;</span> pcl_ops:((<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Tjr_pcache/Ins_del_op_type/index.html#type-op">Tjr_pcache.Ins_del_op_type.op</a>, <span class="type-var">'ptr</span>, <span class="type-var">'t</span>) <a href="../Tjr_pcache/Pcl_types/index.html#type-pcl_ops">Tjr_pcache.Pcl_types.pcl_ops</a> <span>&#45;&gt;</span> with_dmap:((<span class="type-var">'ptr</span>, <span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-dmap_state">dmap_state</a>, <span class="type-var">'t</span>) <a href="../../tjr_monad/Tjr_monad/With_state/index.html#type-with_state">Tjr_monad.With_state.with_state</a> <span>&#45;&gt;</span> (<span class="type-var">'ptr</span>, <span class="type-var">'k</span>, <span class="type-var">'v</span>, <span class="type-var">'t</span>) <a href="index.html#type-dmap_dcl_ops">dmap_dcl_ops</a></code></dt><dt class="spec value" id="val-convert_dcl_to_dmap"><a href="#val-convert_dcl_to_dmap" class="anchor"></a><code><span class="keyword">val </span>convert_dcl_to_dmap : monad_ops:<span class="type-var">'a</span> <a href="../../tjr_monad/Tjr_monad/Types/index.html#type-monad_ops">Tjr_monad.Types.monad_ops</a> <span>&#45;&gt;</span> dmap_dcl_ops:((<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="../Tjr_pcache/Ins_del_op_type/index.html#type-op">Tjr_pcache.Ins_del_op_type.op</a>, (<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-op_map">op_map</a>, <span class="type-var">'d</span>, <span class="type-var">'a</span>) <a href="../Tjr_pcache/Detachable_chunked_list/index.html#type-dcl_ops">Tjr_pcache.Detachable_chunked_list.dcl_ops</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'a</span>) <a href="../Tjr_pcache/Dmap_types/index.html#type-dmap_ops">Tjr_pcache.Dmap_types.dmap_ops</a></code></dt></dl></details></div></div></div></section></div></body></html>