<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lru_doc (tjr_lru_cache.Tjr_lru_cache.Lru_doc)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">tjr_lru_cache</a> &#x00BB; <a href="../index.html">Tjr_lru_cache</a> &#x00BB; Lru_doc</nav><h1>Module <code>Tjr_lru_cache.Lru_doc</code></h1></header><dl><dt class="spec value" id="val-dummy"><a href="#val-dummy" class="anchor"></a><code><span class="keyword">val </span>dummy : unit</code></dt><dd><p>The LRU provides a flushable map API.</p><p>To support blocking/non-blocking modes, we can optionally provide a callback function.</p><p>The following are developer notes.</p><h2 id="sync-behaviour"><a href="#sync-behaviour" class="anchor"></a>Sync behaviour</h2><p>Our main use for this module is as a frontend to an uncached KV store (see tjr_kv).</p><p>There we target the following API: FIXME perhaps move the api here?</p><pre><code class="ml">  type persist_mode = Persist_later | Persist_now

  type mode = persist_mode

  type ('k,'v,'t) flushable_map_ops = {
    find: 'k -&gt; ('v option,'t) m;
    insert: mode -&gt; 'k -&gt; 'v -&gt; (unit,'t) m;
    delete: mode -&gt; 'k -&gt; (unit,'t) m;
    sync_key: 'k -&gt; (unit,'t) m;
    sync_all_keys: unit -&gt; (unit,'t) m;
  }
end</code></pre><h2 id="concurrency"><a href="#concurrency" class="anchor"></a>Concurrency</h2><p>This API is expected to be used by many threads. In particular, for <code>sync_key</code> we may have the following actions:</p><ul><li>thread A: <code>insert_T(k,v); sync_key(k)</code></li><li>thread B: <code>insert_T(k,v'); sync_key(k)</code></li></ul><p>Then the insert of <code>v'</code> may be synced by thread A's <code>sync_key</code>.</p><p>Similarly, for <code>sync_all_keys</code>:</p><ul><li>thread A: <code>insert_T(k,v); sync_all_keys</code></li><li>thread B: <code>insert_T(k,v')</code></li></ul><p>Thread A's call to <code>sync_all_keys</code> may result in <code>(k,v')</code> rather than <code>(k,v)</code>.</p><h2 id="non-blocking-design"><a href="#non-blocking-design" class="anchor"></a>Non-blocking design</h2><p>We want sync operations to be non-blocking.</p><ul><li>For the thread that issues a sync, we want to have the option of avoiding waiting for the sync to complete. For this, we expect the thread doing the call to launch an async thread to invoke the call.</li></ul><ul><li>Transient operations from other threads should not block while a sync is taking place. FIXME implement this</li></ul><ul><li>A concurrent <code>sync_all_keys</code> operation (perhaps occuring halfway through an existing sync) should avoid re-syncing keys that have already been synced.</li></ul><p>The design (for tjr_kv) has a single active thread servicing the pcache. If this thread is solely responsible for <code>sync_all_keys</code>, then transient operations will block (till the thread completes and can service another message from the LRU cache).</p><p>Thus, the question is how to service the <code>sync_all_keys</code> operation in the pcache.</p><p>FIXME another issue: how to suspend a thread in the LRU till we receive notification of the sync completion. For LWT we can just pass some mbox var. For the API perhaps we have a callback function which updates the system state.</p><p>NOTE LMDB has &quot;There can be multiple simultaneously active read-only transactions but only one that can write. Once a single read-write transaction is opened, all further attempts to begin one will block until the first one is committed or aborted.&quot;</p><h2 id="consumed-api"><a href="#consumed-api" class="anchor"></a>Consumed API</h2><p>The LRU provides a &quot;syncable/blocking&quot; map API.</p><p>FIXME terminology: perhaps persistent_mode should be sync_mode? Or should we separate the sync operation from the durability and blocking requirement?</p><p>FIXME sync is a bad word because it implies symmetrical operation, whereas a sync is really an operation at the API which forces changes downwards (flush has this connotation).</p><p>We build the LRU on top of an API which exposes map-like operations together with a sync operation. So the LRU is really just an LRU cache of a syncable map (ie, it consumes a syncable map and produces a syncable map).</p><p>A non-blocking operation can put a msg on the queue and return immediately. A blocking operation has to listen for the reply before returning. There is a question of whether to implement a reply queue or use some simpler mechanism (callback or mbox var). Probably best to use a simple callback.</p><h2 id="marking-entries-clean"><a href="#marking-entries-clean" class="anchor"></a>Marking entries clean</h2><p>On a <code>sync_all_keys call</code>, we can dispatch to the lower layer, and mark all entries clean at that point, without waiting for the return. We only need to wait for the return if the <code>sync_all_keys</code> call is blocking (but we can still mark the entries clean... the blocking behaviour is a notification thing, but marking entries clean is just to record in memory that these entries no longer need to be flushed).</p> <hr/> </dd></dl></div></body></html>