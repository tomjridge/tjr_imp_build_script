<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lru_in_mem (tjr_lru_cache.Tjr_lru_cache.Lru_in_mem)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">tjr_lru_cache</a> &#x00BB; <a href="../index.html">Tjr_lru_cache</a> &#x00BB; Lru_in_mem</nav><h1>Module <code>Tjr_lru_cache.Lru_in_mem</code></h1></header><aside><p>A single-threaded in-memory LRU cache, as a prelude to the real thing.</p><p>We assume all operations complete quickly from the cache. Operations that need to go to disk are modelled using explicit continuation passing.</p><p>We allow values to be tagged with extra info (this will be used to record whether the value needs to be flushed to the lower level). ?FIXME</p><p>The difficulty is how to extend this to deal with disk-backed eviction.</p><p>NOTE that the operations occur not in a monad - instead, explicit state passing is used, and we return the possible evictees; this is a prelude to the real version where we need to do something with the evictees</p></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../index.html#module-Im_types">Im_types</a></code></span></summary><aside></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Entry/index.html#module-Types">Entry.Types</a></code></span></summary><dl><dt class="spec type" id="type-time"><a href="#type-time" class="anchor"></a><code><span class="keyword">type </span>time</code><code><span class="keyword"> = </span>int</code></dt><dd><p>The cache maintains an internal clock.</p></dd></dl><dl><dt class="spec type" id="type-dirty"><a href="#type-dirty" class="anchor"></a><code><span class="keyword">type </span>dirty</code><code><span class="keyword"> = </span>bool</code></dt><dd><p>Entries are marked using a bool; true means &quot;this is dirty&quot;.</p></dd></dl><dl><dt class="spec type" id="type-entry_type"><a href="#type-entry_type" class="anchor"></a><code><span class="keyword">type </span>'v entry_type</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-entry_type.Insert" class="anchored"><td class="def constructor"><a href="#type-entry_type.Insert" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Insert</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-entry_type.value" class="anchored"><td class="def field"><a href="#type-entry_type.value" class="anchor"></a><code>value : <span class="type-var">'v</span>;</code></td></tr><tr id="type-entry_type.dirty" class="anchored"><td class="def field"><a href="#type-entry_type.dirty" class="anchor"></a><code>dirty : <a href="index.html#type-dirty">dirty</a>;</code></td></tr></table><code>}</code><code></code></td></tr><tr id="type-entry_type.Delete" class="anchored"><td class="def constructor"><a href="#type-entry_type.Delete" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Delete</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-entry_type.dirty" class="anchored"><td class="def field"><a href="#type-entry_type.dirty" class="anchor"></a><code>dirty : <a href="index.html#type-dirty">dirty</a>;</code></td></tr></table><code>}</code><code></code></td></tr><tr id="type-entry_type.Lower" class="anchored"><td class="def constructor"><a href="#type-entry_type.Lower" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Lower</span><span class="keyword"> of </span><span class="type-var">'v</span> option</code></td></tr></table></dt><dd><p>Cache map entries; values in the map are tagged with a last-accessed time and a dirty flag</p><p>Entries in the cache for key k:</p><ul><li><p>Insert v (dirty=true/false)</p><ul><li>this occurs on insert</li></ul></li><li>Delete (dirty=true/false)</li><li><p>Lower vopt</p><ul><li>this occurs when we check the lower layer for a non-existing entry in cache</li></ul></li><li><p>(No entry)</p><ul><li>for a key that hasn't been seen before</li></ul></li></ul><p>Additionally, each entry has a last-accessed time</p></dd></dl><dl><dt class="spec type" id="type-entry"><a href="#type-entry" class="anchor"></a><code><span class="keyword">type </span>'v entry</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-entry.entry_type" class="anchored"><td class="def field"><a href="#type-entry.entry_type" class="anchor"></a><code>entry_type : <span class="type-var">'v</span> <a href="index.html#type-entry_type">entry_type</a>;</code></td></tr><tr id="type-entry.atime" class="anchored"><td class="def field"><a href="#type-entry.atime" class="anchor"></a><code>atime : <a href="index.html#type-time">time</a>;</code></td></tr></table><code>}</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../Im_cache_state/index.html#module-Types">Im_cache_state.Types</a></code></span></summary><div class="spec module" id="module-Map_int"><a href="#module-Map_int" class="anchor"></a><code><span class="keyword">module </span>Map_int = <a href="../../../tjr_lib_core/Tjr_map/index.html#module-Map_int">Tjr_map.Map_int</a></code></div><dl><dt class="spec module" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span class="keyword">module </span>Queue = <a href="index.html#module-Map_int">Map_int</a></code></dt><dd><p>We maintain a queue as a map from time to key that was accessed at that time.</p></dd></dl><dl><dt class="spec type" id="type-cache_state"><a href="#type-cache_state" class="anchor"></a><code><span class="keyword">type </span>('k, 'v) cache_state</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-cache_state.max_size" class="anchored"><td class="def field"><a href="#type-cache_state.max_size" class="anchor"></a><code>max_size : int;</code></td></tr><tr id="type-cache_state.evict_count" class="anchored"><td class="def field"><a href="#type-cache_state.evict_count" class="anchor"></a><code>evict_count : int;</code></td></tr><tr id="type-cache_state.current_time" class="anchored"><td class="def field"><a href="#type-cache_state.current_time" class="anchor"></a><code>current_time : <a href="../Entry/Types/index.html#type-time">Entry.Types.time</a>;</code></td></tr><tr id="type-cache_state.cache_map" class="anchored"><td class="def field"><a href="#type-cache_state.cache_map" class="anchor"></a><code>cache_map : (<span class="type-var">'k</span>, <span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a>) <a href="../../../tjr_polymap/Tjr_polymap/index.html#type-t">Tjr_polymap.t</a>;</code></td></tr><tr id="type-cache_state.queue" class="anchored"><td class="def field"><a href="#type-cache_state.queue" class="anchor"></a><code>queue : <span class="type-var">'k</span> <a href="../../../tjr_lib_core/Tjr_map/Map_int/index.html#type-t">Queue.t</a>;</code></td><td class="doc"><p>map from time to key that was accessed at that time</p></td></tr></table><code>}</code></dt><dd><p>The <code>cache_state</code> consists of:</p><ul><li><code>max_size</code>: the max number of entries in the cache</li></ul><ul><li><code>evict_count</code>: number of entries to evict when cache full; for <code>tjr_kv</code> performance is best when the <code>evict_count</code> is such that the evictees fit nicely in a block</li></ul><ul><li><code>current_time</code>: the current time (monotonically increasing); increased on each operation</li></ul><ul><li><code>cache_map</code>: the cache entries, a map from key to <code>'v value</code></li></ul><ul><li><code>queue</code>: a map from time to key that was accessed at that time; only holds the latest time a key was accessed (earlier entries for key k are deleted when a new operation on k occurs).</li></ul><p>NOTE the <code>queue</code> field allows to identify the least recently used without walking the entire map.</p></dd></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include </span><a href="../index.html#module-Im_ops_type">Im_ops_type</a></code></span></summary><aside></aside><dl><dt class="spec type" id="type-lru_in_mem_ops"><a href="#type-lru_in_mem_ops" class="anchor"></a><code><span class="keyword">type </span>('k, 'v, 't) lru_in_mem_ops</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-lru_in_mem_ops.find" class="anchored"><td class="def field"><a href="#type-lru_in_mem_ops.find" class="anchor"></a><code>find : <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> <span>&#45;&gt;</span> [ `In_cache of <span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a><span class="keyword"> | </span>`Not_in_cache of vopt_from_lower:<span class="type-var">'v</span> option <span>&#45;&gt;</span> cache_state:(<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> <span>&#45;&gt;</span> <span class="type-var">'v</span> option<span class="keyword"> * </span>[ `Evictees of (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a>) list option ]<span class="keyword"> * </span>[ `Cache_state of (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> ] ];</code></td></tr><tr id="type-lru_in_mem_ops.insert" class="anchored"><td class="def field"><a href="#type-lru_in_mem_ops.insert" class="anchor"></a><code>insert : <span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> <span>&#45;&gt;</span> [ `Evictees of (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a>) list option ]<span class="keyword"> * </span>[ `Cache_state of (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> ];</code></td></tr><tr id="type-lru_in_mem_ops.delete" class="anchored"><td class="def field"><a href="#type-lru_in_mem_ops.delete" class="anchor"></a><code>delete : <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> <span>&#45;&gt;</span> [ `Evictees of (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a>) list option ]<span class="keyword"> * </span>[ `Cache_state of (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> ];</code></td></tr><tr id="type-lru_in_mem_ops.sync_key" class="anchored"><td class="def field"><a href="#type-lru_in_mem_ops.sync_key" class="anchor"></a><code>sync_key : <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> <span>&#45;&gt;</span> [ `Not_present<span class="keyword"> | </span>`Present of <span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a><span class="keyword"> * </span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="../Im_cache_state/Types/index.html#type-cache_state">Im_cache_state.Types.cache_state</a> ];</code></td></tr></table><code>}</code></dt><dd><p>This type is what is returned by the <code>make_lru_in_mem</code> function.</p><p>NOTE that <code>sync_key</code> performs only the in-mem updates (ie clearing the dirty flag). If you want to flush to disk, you have to do something else (see <code>Lru_multithreaded</code>).</p></dd></dl></details></div></div></div></details></div></div></div><dl><dt class="spec value" id="val-test"><a href="#val-test" class="anchor"></a><code><span class="keyword">val </span>test : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>FIXME tests are enabled; disable for production</p></dd></dl><dl><dt class="spec value" id="val-tick"><a href="#val-tick" class="anchor"></a><code><span class="keyword">val </span>tick : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-cache_state">cache_state</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) <a href="index.html#type-cache_state">cache_state</a></code></dt><dt class="spec value" id="val-find_in_cache"><a href="#val-find_in_cache" class="anchor"></a><code><span class="keyword">val </span>find_in_cache : update_time:bool <span>&#45;&gt;</span> <span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a> <span>&#45;&gt;</span> <span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a> option<span class="keyword"> * </span>(<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a></code></dt><dd><p>Attempt to locate key in cache.</p></dd></dl><dl><dt class="spec exception" id="exception-E_"><a href="#exception-E_" class="anchor"></a><code><span class="keyword">exception </span></code><code><span class="exception">E_</span></code></dt><dd><p>An exception, for quick abort. FIXME remove</p></dd></dl><dl><dt class="spec value" id="val-make_cached_map"><a href="#val-make_cached_map" class="anchor"></a><code><span class="keyword">val </span>make_cached_map : unit <span>&#45;&gt;</span> (find:(<span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'a</span>) <a href="index.html#type-cache_state">cache_state</a> <span>&#45;&gt;</span> [&gt; `In_cache of <span class="type-var">'a</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a><span class="keyword"> | </span>`Not_in_cache of vopt_from_lower:<span class="type-var">'v</span> option <span>&#45;&gt;</span> cache_state:(<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a> <span>&#45;&gt;</span> <span class="type-var">'v</span> option<span class="keyword"> * </span>[&gt; `Evictees of (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a>) list option ]<span class="keyword"> * </span>[&gt; `Cache_state of (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a> ] ]) <span>&#45;&gt;</span> insert:(<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a> <span>&#45;&gt;</span> [&gt; `Evictees of (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a>) list option ]<span class="keyword"> * </span>[&gt; `Cache_state of (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a> ]) <span>&#45;&gt;</span> delete:(<span class="type-var">'k</span> <span>&#45;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a> <span>&#45;&gt;</span> [&gt; `Evictees of (<span class="type-var">'k</span><span class="keyword"> * </span><span class="type-var">'v</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a>) list option ]<span class="keyword"> * </span>[&gt; `Cache_state of (<span class="type-var">'k</span>, <span class="type-var">'v</span>) <a href="index.html#type-cache_state">cache_state</a> ]) <span>&#45;&gt;</span> sync_key:(<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-cache_state">cache_state</a> <span>&#45;&gt;</span> [&gt; `Not_present<span class="keyword"> | </span>`Present of <span class="type-var">'c</span> <a href="../Entry/Types/index.html#type-entry">Entry.Types.entry</a><span class="keyword"> * </span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="index.html#type-cache_state">cache_state</a> ]) <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> <span class="type-var">'d</span></code></dt><dd><p>Construct the cached map on top of an existing map.</p><p>NOTE the idea for <code>find</code> is that we execute a quick step to handle the case that there is an entry in the cache. If there isn't, we make a slow call to the lower layer, and when the result arrives we make another update to the cache state with the then current state of the cache. To avoid the risk of stale results being returned from lower, we have to tag lower results with some kind of monotonically-increasing index.</p></dd></dl><dl><dt class="spec value" id="val-make_lru_in_mem"><a href="#val-make_lru_in_mem" class="anchor"></a><code><span class="keyword">val </span>make_lru_in_mem : unit <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>) <a href="../Im_ops_type/index.html#type-lru_in_mem_ops">Im_ops_type.lru_in_mem_ops</a></code></dt><dd><p>Package up the operations in a record</p></dd></dl></div></body></html>